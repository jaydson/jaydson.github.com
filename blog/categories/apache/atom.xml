<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Apache | Jaydson Gomes]]></title>
  <link href="http://jaydson.org/blog/categories/apache/atom.xml" rel="self"/>
  <link href="http://jaydson.org/"/>
  <updated>2013-01-09T19:46:03-02:00</updated>
  <id>http://jaydson.org/</id>
  <author>
    <name><![CDATA[Jaydson Gomes]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Apache - Criando Virtual Hosts]]></title>
    <link href="http://jaydson.org/apache-criando-virtual-hosts/"/>
    <updated>2010-09-07T22:35:55-03:00</updated>
    <id>http://jaydson.org/apache-criando-virtual-hosts</id>
    <content type="html"><![CDATA[<p>According to the <a href='http://httpd.apache.org/docs/1.3/vhosts/'>Apache documentation</a>, the term <strong>Virtual Host</strong> refers to the practice of keeping more than one server on one machine, distinguished by their names.</p>

<p>I will not talk about settings on production servers, but on the development environment.</p>

<p>We can create an environment where each application can have its own domain.</p>

<p>Example:</p>

<p>To access the application TheWebMind in my local environment I need to access the following address:</p>

<p><strong>http://localhost/projetos/open-soruce/thewebmind/2.0/trunk</strong></p>

<p>Segundo a <a href='http://httpd.apache.org/docs/1.3/vhosts/'>documentação do Apache</a>, o conceito de <strong>Virtual Host</strong> refere-se à prática de manter mais de um servidor em uma máquina, diferenciados pelos seus nomes. Não vou me deter a falar sobre configurações em servidores de produção, mas sim em ambiente de desenvolvimento mesmo. Podemos criar um ambiente onde cada aplicação local pode ter seu próprio domínio.</p>

<p>Exemplo:</p>

<p>Para acessar a aplicação <strong>TheWebMind</strong> em meu ambiente local eu preciso acessar o seguinte endereço: <strong>http://localhost/projetos/open-soruce/thewebmind/2.0/trunk</strong></p>

<p>Não seria legal se eu pudesse acessar apenas com <strong>http://mind</strong> ?</p>

<p>Bom, essa configuração é simples de fazer, bastando alguns segundos de seu tempo.</p>

<p>Crie um arquivo com o nome do domínio desejado <span>.conf</span> no diretório: <strong>/etc/apache2/sites-available</strong></p>

<p>No meu caso, foi <strong>mind.conf<!-- more --> Would not it be nice if I could access only http://mind?</strong></p>

<p>Well, this configuration is simple to make, just a few seconds of your time.</p>

<p>Create a file with the name of the desired domain <span>. Conf</span> in the directory: <strong>/etc/apache2/sites-available</strong></p>

<p>In my case it was mind.conf</p>

<p>This file should contain the following contents:</p>

<p><strong><pre class='markdown-html-error' style='border: solid 3px red; background-color: pink'>REXML could not parse this XML/HTML: 
&lt;VirtualHost your_domain&gt;</pre></strong></p>

<p>ServerAdmin webmaster@localhost</p>

<p>ServerAlias www.<strong>your_domain</strong></p>

<p>DocumentRoot directory_of_your_application</p>]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Habilitar mod_rewrite no Apache]]></title>
    <link href="http://jaydson.org/habilitar-mod_rewrite-no-apache/"/>
    <updated>2010-09-06T22:46:51-03:00</updated>
    <id>http://jaydson.org/habilitar-mod_rewrite-no-apache</id>
    <content type="html"><![CDATA[<p>One thing I always do, but I always forget how to do is enable the <a href='http://httpd.apache.org/docs/1.3/mod/mod_rewrite.html'>mod_rewrite</a> in Apache.</p>

<p>For those not familiar, this is an Apache module that uses a mechanism based on rewrite rules (based on a parser for regular expressions).</p>

<p>Basically the module allows the rewriting of URLs on the fly.</p>

<p>To enable the module into Apache just this line:</p>

<p><strong>$ Sudo a2enmod rewriteUma coisa que sempre faço, mas sempre esqueço como fazer é habilitar o <a href='http://httpd.apache.org/docs/1.3/mod/mod_rewrite.html'>mod_rewrite</a> do Apache. Para quem não conhece, esse é um módulo do Apache que utiliza um mecanismo baseado em regras de reescrita (baseadas em um parser de expressões regulares). Basicamente o módulo permite a reescrita de URL&#8217;s _on the fly_.</strong></p>

<p>Para habilitar o módulo no Apache basta esta linha: <strong>$ sudo a2enmod rewrite<!-- more --></strong></p>

<p>Now open the configuration file</p>

<p><strong>$ Sudo gedit / etc/apache2/sites-available/default</strong></p>

<p>Look in your input file to &#8220;AllowOverride None&#8221; in my case was in line 11.</p>

<p>Change this value to &#8221;<strong>AllowOverride Al</strong>l&#8221;.</p>

<p>Save the file and restart Apache.</p>

<p><strong>$ Sudo / etc/init.d/apache2 restart</strong></p>

<p>Basically that&#8217;s it, now is possible to rewrite URL&#8217;s.</p>

<p>**</p>

<p>Agora abra o arquivo de configuração <strong>$ sudo gedit  /etc/apache2/sites-available/default</strong></p>

<p>Procure no seu arquivo a entrada &#8220;AllowOverride None&#8221;, no meu caso estava na linha 11. Altere esse valor para &#8221;<strong>AllowOverride All</strong>&#8221; . Salve o arquivo e reinicie o Apache. <strong>$ sudo /etc/init.d/apache2 restart</strong></p>

<p>Basicamente é isso, agora já é possível reescrever  URL&#8217;s.</p>]]></content>
  </entry>
  
</feed>
